Nondeterministic finite automata (NFAs) are defined almost the same way as DFAs.
There are two differences: There can be more than one initial state.
Also, multiple transitions carrying the same input symbol can connect a state to different
successor states.

\begin{definition}
    A DFA can be defined using the following five components:

    \begin{itemize}
        \item A set of vertices $Q_N$, called states.
        Also for NFAs this set has to be finite.
        \item A set of labels $\Sigma_N$ on the vertices which is called the alphabet of input symbols.
        It has to be finite as well.
        \item A set of vertices called ``initial'' states $S_N \subseteq Q_N$.
        \item A number of states $F_N \subseteq Q_N$ called accepting states.
        \item A set of directed edges called transitions.
        Each transition is labelled with one input symbol.
        This set can be represented by a total function
        $\Delta_N : Q_N \times \Sigma_N \rightarrow \mathcal{P}(Q_N)$ which
        associates a set of successor states to every pair of states and input symbols.
    \end{itemize}
\end{definition}

Also NFAs can be used to decide whether a word $w$ is decided in a language $L$.
The idea is the same as for DFAs: the word $w$ is treated as a sequence of input symbols.
This sequence is then again used to traverse the graph from a starting state.
If the traversal ends in an accepting state then the word is said to be accepted.

NFAs complicate this procedure though because from every state more than one
transition, or no transition at all, is allowed to lead to successor states.
Also, there can be more than one initial states, or none at all.
Therefore it is in general not possible to know up front for a sequence of input symbols
a sequence of transitions which will lead to an accepting state.

The solution is to simulate all possible executions of the automaton.
This is done by extending the transition function to take a set of states as input.
The intuition is to compute the set of possible successor state for each encountered state and input symbol.
This reduces our problem to another set of states and a shorter word.

\begin{definition}
    The extended transition function $\hat\Delta$ takes a set of states and a
    word as input and inductively computes all states which can be reached
    after traversing the automaton as indicated by the word.

    \begin{align}
        \hat\Delta(R, \epsilon) &= R \\
        \hat\Delta(R, c w) &= \hat\Delta(\bigcup\limits_{r \in R} \Delta(r, c), w)
    \end{align}
\end{definition}

The function $\hat\Delta$ can now be used to determine whether a word is accepted by an NFA:

\begin{align}
    w \in L \Leftrightarrow \hat\Delta(S_{M_L}, w) \subseteq F_{M_L}
\end{align}

\begin{definition}
    Every NFA $N$ can be converted into a DFA $D_N$ as follows:
\end{definition}
