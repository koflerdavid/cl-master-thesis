%% LaTeX2e file `content.tex'
%% generated by the `filecontents' environment
%% from source `CLaTeX' on 2017/02/06.
%%

\chapter{Introduction}

\chapter{Theoretical background and literature review}

\section{Automata theory}

Automata theory concerns the study of abstract automata and computational models.
The aim is to study their essential properties and which types of computational problems can be solved bz using them.

\subsection{Basic definitions}

\begin{definition}
    The set of all finite sequences of an alphabet $\Sigma$ is written as $\Sigma^\ast$.
    It is formally defned as
        $\Sigma^\ast = \cup_{i=0}^{\inf} \{c_1 c_2 \ldots c_i | \forall 1 \le i \le n: c_i \in \Sigma \} $
    A language is a subset of $\Sigma^\ast$.
\end{definition}

The empty sequence (containing no symbols at a all) is represented by $\epsilon$.

\subsection{Deterministic finite automata}

\begin{definition}
    Deterministic finite automata (DFAs) can be thought of as graphs with labeled vertices and edges.
    A DFA can be defined using the following five components:

    \begin{itemize}
        \item its set of vertices $Q_D$, called states. As implied by the term DFA, this set has to be finite.
        \item a set of labels $\Sigma_D$ on the vertices which is called the alphabet of input symbols.
                It has to be finite as well.
        \item an ``initial'' state $s_D \in Q_D$.
        \item a number of states $F_D \subseteq Q_D$ called accepting states.
        \item the set of directed edges called transitions.
                Each transition is labelled with one input symbol.
                There is exactly one transition between each and every state.
                Because of this, this set is usually represented by a total function $\delta_D : (Q_D, \Sigma) \rightarrow Q_D$ which
                associates a destination state to every pair of state and input symbol.
    \end{itemize}
\end{definition}

DFAs are chiefly used to represent transition systems.
A system modeled by the automata is thought of always being in one of the states contained in the automata.
When the system receives an input, a transition to another state is possible.

For certain classes of languages, a DFA can be used to decide whether a specific word $w$ is contained in a language $L$.
This is done by first constructing an appropriate automata $M_L$ for the language.
Then, the transition system is initialized to be at the initial state $s_{M_L}$.
Then, the word $w$ is treated as a sequence of input symbols $c_1 c_2 \ldots c_n$.
For each input symbol, the state transition $\delta_{M_L}(q, c)$ matching the current state $q$ and input symbol $c$ is followed.
If the system reaches one of the accepting states and there are no more input symbols left, then the
automata is said to accept the input.
For this to prove that $w \in L$, it is necessary that reaching an accepting state of $M_L$ using $w$ is equivalent to membership of $w$ in $L$.
A proof of the algorithm used to derive $M_L$ is required to ensure this.

The following lines formally describe this procedure:
\begin{align}
    w \in L \Leftrightarrow \hat\delta_{M_L}(s_{M_L}, w) \in F_{M_L} \\
\end{align}

\begin{definition}
    $\hat\delta$ is the transition function of the automaton $M_L$, extended to words.
    This is done by using induction over the length of the input word.
    \begin{align}
        \hat\delta_M(q, \epsilon) &= q\\
        \hat\delta_M(q, c w) &= \hat\delta_M(\delta_M(q, c), w)
    \end{align}
\end{definition}

\begin{definition}
    The set of words accepted by starting from a state $q$ is said to be the language of $q$.
    The language accepted by the initial state of an automata $M$ is the language of $M$.

    \begin{align}
        \mathcal{L}(q) &= \{ w \in \Sigma^\ast | \hat\delta_M(q, w) \in F_M \}\\
        \mathcal{L}(M) &= \mathcal{L}(s_M)
    \end{align}
\end{definition}

\subsection{Nondeterministic finite automata}

\subsection{Regular expressions}

\subsection{Derivatives of regular expressions}

\subsection{Equivalence of finite automata and regular expressions}

\section{Automata equivalence and inclusion}

\subsection{Automata equivalence}

\subsection{Hopcroft and Karp's algorithm}

\subsection{Exploitation of closure properties}

\subsection{Antichain methods}

\chapter{Congruence closure tool and experiments}

\section{Congruence closure tool}

\subsection{Goals}

\subsection{Implementation}

\section{Experiments}

\subsection{Bonchi and Pous' results}

\subsection{}

\subsection{Experimental setup}

\subsection{Results}

\chapter{Conclusion}
